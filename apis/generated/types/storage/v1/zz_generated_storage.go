// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package v1
// +kubebuilder:object:generate=true

import (
	resource "github.com/eu-sovereign-cloud/ecp/apis/generated/types/resource"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for ImageSpecBoot.
const (
	BIOS ImageSpecBoot = "BIOS"
	UEFI ImageSpecBoot = "UEFI"
)

// Defines values for ImageSpecCpuArchitecture.
const (
	Amd64 ImageSpecCpuArchitecture = "amd64"
	Arm64 ImageSpecCpuArchitecture = "arm64"
)

// Defines values for ImageSpecInitializer.
const (
	Cloudinit22 ImageSpecInitializer = "cloudinit-22"
	None        ImageSpecInitializer = "none"
)

// Defines values for StorageSkuSpecType.
const (
	LocalDurable   StorageSkuSpecType = "local-durable"
	LocalEphemeral StorageSkuSpecType = "local-ephemeral"
	RemoteDurable  StorageSkuSpecType = "remote-durable"
)

// Defines values for AcceptHeader.
const (
	AcceptHeaderApplicationjson            AcceptHeader = "application/json"
	AcceptHeaderApplicationjsonDeletedOnly AcceptHeader = "application/json; deleted=only"
	AcceptHeaderApplicationjsonDeletedTrue AcceptHeader = "application/json; deleted=true"
)

// Defines values for ListImagesParamsAccept.
const (
	ListImagesParamsAcceptApplicationjson            ListImagesParamsAccept = "application/json"
	ListImagesParamsAcceptApplicationjsonDeletedOnly ListImagesParamsAccept = "application/json; deleted=only"
	ListImagesParamsAcceptApplicationjsonDeletedTrue ListImagesParamsAccept = "application/json; deleted=true"
)

// Defines values for ListSkusParamsAccept.
const (
	ListSkusParamsAcceptApplicationjson            ListSkusParamsAccept = "application/json"
	ListSkusParamsAcceptApplicationjsonDeletedOnly ListSkusParamsAccept = "application/json; deleted=only"
	ListSkusParamsAcceptApplicationjsonDeletedTrue ListSkusParamsAccept = "application/json; deleted=true"
)

// Defines values for ListBlockStoragesParamsAccept.
const (
	ListBlockStoragesParamsAcceptApplicationjson            ListBlockStoragesParamsAccept = "application/json"
	ListBlockStoragesParamsAcceptApplicationjsonDeletedOnly ListBlockStoragesParamsAccept = "application/json; deleted=only"
	ListBlockStoragesParamsAcceptApplicationjsonDeletedTrue ListBlockStoragesParamsAccept = "application/json; deleted=true"
)

// BlockStorageIterator Iterator for block-storages
type BlockStorageIterator struct {
	// Items List of block-storages
	Items []BlockStorage `json:"items"`

	// Metadata Metadata for response objects.
	Metadata resource.ResponseMetadata `json:"metadata"`
}

// BlockStorage defines model for BlockStorage.
type BlockStorage struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	// The number of annotations is eventually limited by the CSP.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions User-defined key/value pairs that are mutable and can be used to add extensions.
	// Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	// The number of labels is eventually limited by the CSP.
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Metadata for regional resources with name, permission, modification, type, tenant and workspace and region information.
	Metadata *resource.RegionalWorkspaceResourceMetadata `json:"metadata,omitempty"`

	// Spec resource.References the SKU used for this block.
	// If a reference to the source image is used as the base for creating this block storage.
	Spec BlockStorageSpec `json:"spec"`

	Status *BlockStorageStatus `json:"status,omitempty"`
}

// BlockStorageSpec References the SKU used for this block.
// If a reference to the source image is used as the base for creating this block storage.
type BlockStorageSpec struct {
	// SizeGB Size of the block storage in GB.
	SizeGB int `json:"sizeGB"`

	// SkuRef resource.Reference to the SKU of the block storage.
	SkuRef resource.Reference `json:"skuRef"`

	// SourceImageRef resource.Reference to the source image used as the base for creating the block storage.
	SourceImageRef *resource.Reference `json:"sourceImageRef,omitempty"`
}

// BlockStorageStatus defines model for BlockStorageStatus.
type BlockStorageStatus struct {
	// AttachedTo resource.Reference to the instance the block storage is attached to.
	AttachedTo *resource.Reference        `json:"attachedTo,omitempty"`
	Conditions []resource.StatusCondition `json:"conditions"`

	// SizeGB Size of the block storage in GB.
	SizeGB int `json:"sizeGB"`

	// State Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fulfill the request; would be related to provider issue or customer related input.
	State *resource.ResourceState `json:"state,omitempty"`
}

// Image defines model for Image.
type Image struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	// The number of annotations is eventually limited by the CSP.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions User-defined key/value pairs that are mutable and can be used to add extensions.
	// Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	// The number of labels is eventually limited by the CSP.
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Metadata for regional resources with name, permission, modification, type, tenant and region information.
	Metadata *resource.RegionalResourceMetadata `json:"metadata,omitempty"`

	// Spec Detailed specification of the Image resource.
	// The Image is derived from a block storage resource identified by
	// `blockStorageRef` and serves as a template for creating
	// compute instances. For additional information, refer to the
	// [Image Handling](/docs/content/Other/image-handling) section.
	Spec ImageSpec `json:"spec"`

	Status *ImageStatus `json:"status,omitempty"`
}

// ImageIterator Iterator for images
type ImageIterator struct {
	// Items List of images
	Items []Image `json:"items"`

	// Metadata Metadata for response objects.
	Metadata resource.ResponseMetadata `json:"metadata"`
}

// ImageSpec Detailed specification of the Image resource.
// The Image is derived from a block storage resource identified by
// `blockStorageRef` and serves as a template for creating
// compute instances. For additional information, refer to the
// [Image Handling](/docs/content/Other/image-handling) section.
type ImageSpec struct {
	// BlockStorageRef resource.Reference to the block storage used to store the image.
	BlockStorageRef resource.Reference `json:"blockStorageRef"`

	// Boot Boot type for the Image
	Boot *ImageSpecBoot `json:"boot,omitempty"`

	// CpuArchitecture CPU architecture for the Image
	CpuArchitecture ImageSpecCpuArchitecture `json:"cpuArchitecture"`

	// Initializer Initializer for the Image
	Initializer *ImageSpecInitializer `json:"initializer,omitempty"`
}

// ImageSpecBoot Boot type for the Image
type ImageSpecBoot string

// ImageSpecCpuArchitecture CPU architecture for the Image
type ImageSpecCpuArchitecture string

// ImageSpecInitializer Initializer for the Image
type ImageSpecInitializer string

// ImageStatus defines model for ImageStatus.
type ImageStatus struct {
	Conditions []resource.StatusCondition `json:"conditions"`

	// SizeMB Size of the Image in MB
	SizeMB *int `json:"sizeMB,omitempty"`

	// State Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fulfill the request; would be related to provider issue or customer related input.
	State *resource.ResourceState `json:"state,omitempty"`
}

// SkuIterator Iterator for skus
type SkuIterator struct {
	// Items List of skus
	Items []StorageSku `json:"items"`

	// Metadata Metadata for response objects.
	Metadata resource.ResponseMetadata `json:"metadata"`
}

// StorageSku defines model for StorageSku.
type StorageSku struct {
	// Annotations System-defined key/value pairs to annotate the resource.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions System-defined key/value pairs to document available extensions.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels System-defined key/value pairs to filter resources.
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Metadata for SKU resources.
	Metadata *resource.SkuResourceMetadata `json:"metadata,omitempty"`

	// Spec Specification of the storage SKU, including its capabilities and extensions.
	Spec *StorageSkuSpec `json:"spec,omitempty"`
}

// StorageSkuSpec Specification of the storage SKU, including its capabilities and extensions.
type StorageSkuSpec struct {
	// Iops The number of IOPS (Input/Output Operations Per Second) guaranteed for
	// the storage SKU.
	Iops int `json:"iops"`

	// MinVolumeSize Minimum volume size for guaranteed performance, in GB.
	MinVolumeSize int `json:"minVolumeSize"`

	// Type Type of storage SKU. Can be one of the following:
	//
	// * `local-ephemeral`: Local storage is directly attached to the hypervisor
	//   hosting the instance. In the event of a hypervisor failure or instance
	//   restart, the data may either be lost or become unavailable. The failure
	//   mode depends on the Cloud Service Provider (CSP).
	//   Users of local storage should be aware of these risks and implement
	//   a robust backup strategy or application level replication of the data.
	//   Local storage is typically suited for high-performance workloads requiring
	//   low latency and high throughput, where the application layer can handle
	//   failures. It is not recommended for workloads demanding high availability
	//   or data durability. Example use-cases include caching, temporary data
	//   or immutable workloads such as operating system images without local data.
	// * `local-durable`: Local durable storage is similar to local storage
	//   but is designed to provide data durability while providing high-performance.
	//   It is typically implemented using a redundant storage device or
	//   replicated storage solution. Local durable storage is suitable for
	//   workloads requiring high performance and low latency, while also
	//   ensuring data durability at the cost of availability. The time to
	//   restore data may vary depending on the CSP and the
	//   will be significantly higher then using `remote-durable` storage.
	//   Example use-cases include replicated paxos or raft based databases or
	//   replicated databases using synchronous replication, in addition to
	//   file storage.
	// * `remote-durable`: Remote storage is a network-attached storage solution
	//   designed to provide data redundancy and high availability. While
	//   typically slower than local storage, remote storage offers the
	//   advantage of being accessible by different hypervisors.
	//   This means the storage can be used by different instances running
	//   on separate hypervisors, but only one instance at a time. This
	//   enabled the recreation of the instance with the same storage on a
	//   different hypervisor and therefore greatly reduces the recovery
	//   time in case of failure of the hypervisor. Remote storage cannot be
	//   attached to multiple instances simultaneously.
	//   Example use-cases include file storage or replicated databases
	//   using asynchronous replication.
	Type StorageSkuSpecType `json:"type"`
}

// StorageSkuSpecType Type of storage SKU. Can be one of the following:
//
//   - `local-ephemeral`: Local storage is directly attached to the hypervisor
//     hosting the instance. In the event of a hypervisor failure or instance
//     restart, the data may either be lost or become unavailable. The failure
//     mode depends on the Cloud Service Provider (CSP).
//     Users of local storage should be aware of these risks and implement
//     a robust backup strategy or application level replication of the data.
//     Local storage is typically suited for high-performance workloads requiring
//     low latency and high throughput, where the application layer can handle
//     failures. It is not recommended for workloads demanding high availability
//     or data durability. Example use-cases include caching, temporary data
//     or immutable workloads such as operating system images without local data.
//   - `local-durable`: Local durable storage is similar to local storage
//     but is designed to provide data durability while providing high-performance.
//     It is typically implemented using a redundant storage device or
//     replicated storage solution. Local durable storage is suitable for
//     workloads requiring high performance and low latency, while also
//     ensuring data durability at the cost of availability. The time to
//     restore data may vary depending on the CSP and the
//     will be significantly higher then using `remote-durable` storage.
//     Example use-cases include replicated paxos or raft based databases or
//     replicated databases using synchronous replication, in addition to
//     file storage.
//   - `remote-durable`: Remote storage is a network-attached storage solution
//     designed to provide data redundancy and high availability. While
//     typically slower than local storage, remote storage offers the
//     advantage of being accessible by different hypervisors.
//     This means the storage can be used by different instances running
//     on separate hypervisors, but only one instance at a time. This
//     enabled the recreation of the instance with the same storage on a
//     different hypervisor and therefore greatly reduces the recovery
//     time in case of failure of the hypervisor. Remote storage cannot be
//     attached to multiple instances simultaneously.
//     Example use-cases include file storage or replicated databases
//     using asynchronous replication.
type StorageSkuSpecType string

// AcceptHeader defines model for acceptHeader.
type AcceptHeader string

// IfUnmodifiedSince defines model for ifUnmodifiedSince.
type IfUnmodifiedSince = int

// LabelSelector defines model for labelSelector.
type LabelSelector = string

// LimitParam defines model for limitParam.
type LimitParam = int

// ResourcePathParam defines model for resourcePathParam.
type ResourcePathParam = string

// SkipTokenParam defines model for skipTokenParam.
type SkipTokenParam = string

// TenantPathParam defines model for tenantPathParam.
type TenantPathParam = string

// WorkspacePathParam defines model for workspacePathParam.
type WorkspacePathParam = string

// ListImagesParams defines parameters for ListImages.
type ListImagesParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: \*key\*=\*value\* - substring (contains) match on both key and value. Each `*` can appear at start, end or in the middle to mean "any characters". Example: \*env\*=\*prod\* matches a label key containing "env" whose value contains "prod".
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListImagesParamsAccept `json:"Accept,omitempty"`
}

// ListImagesParamsAccept defines parameters for ListImages.
type ListImagesParamsAccept string

// DeleteImageParams defines parameters for DeleteImage.
type DeleteImageParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateImageParams defines parameters for CreateOrUpdateImage.
type CreateOrUpdateImageParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// ListSkusParams defines parameters for ListSkus.
type ListSkusParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: \*key\*=\*value\* - substring (contains) match on both key and value. Each `*` can appear at start, end or in the middle to mean "any characters". Example: \*env\*=\*prod\* matches a label key containing "env" whose value contains "prod".
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListSkusParamsAccept `json:"Accept,omitempty"`
}

// ListSkusParamsAccept defines parameters for ListSkus.
type ListSkusParamsAccept string

// ListBlockStoragesParams defines parameters for ListBlockStorages.
type ListBlockStoragesParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: \*key\*=\*value\* - substring (contains) match on both key and value. Each `*` can appear at start, end or in the middle to mean "any characters". Example: \*env\*=\*prod\* matches a label key containing "env" whose value contains "prod".
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListBlockStoragesParamsAccept `json:"Accept,omitempty"`
}

// ListBlockStoragesParamsAccept defines parameters for ListBlockStorages.
type ListBlockStoragesParamsAccept string

// DeleteBlockStorageParams defines parameters for DeleteBlockStorage.
type DeleteBlockStorageParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateBlockStorageParams defines parameters for CreateOrUpdateBlockStorage.
type CreateOrUpdateBlockStorageParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateImageJSONRequestBody defines body for CreateOrUpdateImage for application/json ContentType.
type CreateOrUpdateImageJSONRequestBody = Image

// CreateOrUpdateBlockStorageJSONRequestBody defines body for CreateOrUpdateBlockStorage for application/json ContentType.
type CreateOrUpdateBlockStorageJSONRequestBody = BlockStorage
