// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package v1

// +kubebuilder:object:generate=true

import (
	resource "github.com/eu-sovereign-cloud/ecp/apis/generated/types/resource"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for IPVersion.
const (
	IPv4 IPVersion = "IPv4"
	IPv6 IPVersion = "IPv6"
)

// Defines values for SecurityGroupRuleSpecDirection.
const (
	Egress  SecurityGroupRuleSpecDirection = "egress"
	Ingress SecurityGroupRuleSpecDirection = "ingress"
)

// Defines values for SecurityGroupRuleSpecProtocol.
const (
	Icmp   SecurityGroupRuleSpecProtocol = "icmp"
	Tcp    SecurityGroupRuleSpecProtocol = "tcp"
	TcpUdp SecurityGroupRuleSpecProtocol = "tcp+udp"
	Udp    SecurityGroupRuleSpecProtocol = "udp"
)

// Defines values for AcceptHeader.
const (
	AcceptHeaderApplicationjson            AcceptHeader = "application/json"
	AcceptHeaderApplicationjsonDeletedOnly AcceptHeader = "application/json; deleted=only"
	AcceptHeaderApplicationjsonDeletedTrue AcceptHeader = "application/json; deleted=true"
)

// Defines values for ListSkusParamsAccept.
const (
	ListSkusParamsAcceptApplicationjson            ListSkusParamsAccept = "application/json"
	ListSkusParamsAcceptApplicationjsonDeletedOnly ListSkusParamsAccept = "application/json; deleted=only"
	ListSkusParamsAcceptApplicationjsonDeletedTrue ListSkusParamsAccept = "application/json; deleted=true"
)

// Defines values for ListInternetGatewaysParamsAccept.
const (
	ListInternetGatewaysParamsAcceptApplicationjson            ListInternetGatewaysParamsAccept = "application/json"
	ListInternetGatewaysParamsAcceptApplicationjsonDeletedOnly ListInternetGatewaysParamsAccept = "application/json; deleted=only"
	ListInternetGatewaysParamsAcceptApplicationjsonDeletedTrue ListInternetGatewaysParamsAccept = "application/json; deleted=true"
)

// Defines values for ListNetworksParamsAccept.
const (
	ListNetworksParamsAcceptApplicationjson            ListNetworksParamsAccept = "application/json"
	ListNetworksParamsAcceptApplicationjsonDeletedOnly ListNetworksParamsAccept = "application/json; deleted=only"
	ListNetworksParamsAcceptApplicationjsonDeletedTrue ListNetworksParamsAccept = "application/json; deleted=true"
)

// Defines values for ListRouteTablesParamsAccept.
const (
	ListRouteTablesParamsAcceptApplicationjson            ListRouteTablesParamsAccept = "application/json"
	ListRouteTablesParamsAcceptApplicationjsonDeletedOnly ListRouteTablesParamsAccept = "application/json; deleted=only"
	ListRouteTablesParamsAcceptApplicationjsonDeletedTrue ListRouteTablesParamsAccept = "application/json; deleted=true"
)

// Defines values for ListSubnetsParamsAccept.
const (
	ListSubnetsParamsAcceptApplicationjson            ListSubnetsParamsAccept = "application/json"
	ListSubnetsParamsAcceptApplicationjsonDeletedOnly ListSubnetsParamsAccept = "application/json; deleted=only"
	ListSubnetsParamsAcceptApplicationjsonDeletedTrue ListSubnetsParamsAccept = "application/json; deleted=true"
)

// Defines values for ListNicsParamsAccept.
const (
	ListNicsParamsAcceptApplicationjson            ListNicsParamsAccept = "application/json"
	ListNicsParamsAcceptApplicationjsonDeletedOnly ListNicsParamsAccept = "application/json; deleted=only"
	ListNicsParamsAcceptApplicationjsonDeletedTrue ListNicsParamsAccept = "application/json; deleted=true"
)

// Defines values for ListPublicIpsParamsAccept.
const (
	ListPublicIpsParamsAcceptApplicationjson            ListPublicIpsParamsAccept = "application/json"
	ListPublicIpsParamsAcceptApplicationjsonDeletedOnly ListPublicIpsParamsAccept = "application/json; deleted=only"
	ListPublicIpsParamsAcceptApplicationjsonDeletedTrue ListPublicIpsParamsAccept = "application/json; deleted=true"
)

// Defines values for ListSecurityGroupsParamsAccept.
const (
	Applicationjson            ListSecurityGroupsParamsAccept = "application/json"
	ApplicationjsonDeletedOnly ListSecurityGroupsParamsAccept = "application/json; deleted=only"
	ApplicationjsonDeletedTrue ListSecurityGroupsParamsAccept = "application/json; deleted=true"
)

// IPVersion IP version of the address
type IPVersion string

// IcmpConfig ICMP specific rule configuration
type IcmpConfig struct {
	// Code ICMP code
	Code int `json:"code"`

	// Type ICMP type
	Type int `json:"type"`
}

// InternetGateway defines model for InternetGateway.
type InternetGateway struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	// The number of annotations is eventually limited by the CSP.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions User-defined key/value pairs that are mutable and can be used to add extensions.
	// Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	// The number of labels is eventually limited by the CSP.
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Metadata for regional resources with name, permission, modification, type, tenant, and region information.
	Metadata *resource.RegionalResourceMetadata `json:"metadata,omitempty"`

	// Spec The internet gateway will use the reserved IP addres.
	// the subnet CIDR block to provide internet access to the subnet.
	Spec InternetGatewaySpec `json:"spec"`

	Status *resource.Status `json:"status,omitempty"`
}

// InternetGatewayIterator Iterator for internet gateways
type InternetGatewayIterator struct {
	// Items List of internet gateways
	Items []InternetGateway `json:"items"`

	// Metadata Metadata for response objects.
	Metadata resource.ResponseMetadata `json:"metadata"`
}

// InternetGatewaySpec The internet gateway will use the reserved IP addres.
// the subnet CIDR block to provide internet access to the subnet.
type InternetGatewaySpec struct {
	// EgressOnly If set to true, the internet gateway will only allow outgoing traffic
	// and will not allow incoming traffic. This is useful for public subnets
	// that should not be accessible from the internet.
	EgressOnly *bool `json:"egressOnly,omitempty"`
}

// Network defines model for Network.
type Network struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	// The number of annotations is eventually limited by the CSP.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions User-defined key/value pairs that are mutable and can be used to add extensions.
	// Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	// The number of labels is eventually limited by the CSP.
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Metadata for regional resources with name, permission, modification, type, tenant, and region information.
	Metadata *resource.RegionalResourceMetadata `json:"metadata,omitempty"`

	// Spec A Network represents a virtual network that can be used to isolate resources.
	// Key network concepts:
	//
	// * Defines a range of IP addresses for compute resources (e.g. instances)
	// * Enables network segmentation and isolation
	// * Provides common performance configuration across the network using a SKU
	//
	// The `cidr` is the base CIDR block for the network. Additional CIDR blocks can be
	// added to the network using the `additionalCidrs` field. The `additionalCidrs` can
	// be changed after the network is created in case they are not used. The main CIDR
	// block cannot be changed after the network is created. All cidrs must be non-overlapping.
	// The cidrs have to be part of the RFC 1918 address space in case of IPv4 and or RFC 4193.
	//
	// In case the system should automatically assign IP addresses to the network cidrs
	// only the network prefix is required. E.g. to request a /16 IPv4 CIDR block the
	// CIDR block would be `0.0.0.0/16` and for a /56 IPv6 CIDR block the CIDR block would
	// be `::/56`. Most CSP will not allow to use a different IPv6 prefix length than /56.
	Spec NetworkSpec `json:"spec"`

	// system. The status contains information about the current state of the network
	// and its CIDR blocks. It will report the status of the CIDR blocks and the network
	// as a whole including automatically assigned IP networks.
	Status *NetworkStatus `json:"status,omitempty"`
}

// NetworkIterator Iterator for networks
type NetworkIterator struct {
	// Items List of networks
	Items []Network `json:"items"`

	// Metadata Metadata for response objects.
	Metadata resource.ResponseMetadata `json:"metadata"`
}

// NetworkSku defines model for NetworkSku.
type NetworkSku struct {
	// Annotations System-defined key/value pairs to annotate the resource.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions System-defined key/value pairs to document available extensions.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels System-defined key/value pairs to filter resources.
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Metadata for SKU resources.
	Metadata *resource.SkuResourceMetadata `json:"metadata,omitempty"`

	// Spec Specification of the network SKU, including its bandwidth and packets per second.
	Spec *NetworkSkuSpec `json:"spec,omitempty"`
}

// NetworkSkuSpec Specification of the network SKU, including its bandwidth and packets per second.
type NetworkSkuSpec struct {
	// Bandwidth The bandwidth in Mbps (Megabits per second).
	Bandwidth int `json:"bandwidth"`

	// Packets The number of packets per second (PPS) that the network SKU can handle.
	Packets int `json:"packets"`
}

// NetworkSpec A Network represents a virtual network that can be used to isolate resources.
// Key network concepts:
//
// * Defines a range of IP addresses for compute resources (e.g. instances)
// * Enables network segmentation and isolation
// * Provides common performance configuration across the network using a SKU
//
// The `cidr` is the base CIDR block for the network. Additional CIDR blocks can be
// added to the network using the `additionalCidrs` field. The `additionalCidrs` can
// be changed after the network is created in case they are not used. The main CIDR
// block cannot be changed after the network is created. All cidrs must be non-overlapping.
// The cidrs have to be part of the RFC 1918 address space in case of IPv4 and or RFC 4193.
//
// In case the system should automatically assign IP addresses to the network cidrs
// only the network prefix is required. E.g. to request a /16 IPv4 CIDR block the
// CIDR block would be `0.0.0.0/16` and for a /56 IPv6 CIDR block the CIDR block would
// be `::/56`. Most CSP will not allow to use a different IPv6 prefix length than /56.
type NetworkSpec struct {
	AdditionalCidrs *[]Cidr `json:"additionalCidrs,omitempty"`

	// Cidr Combined IPv4 and IPv6 CIDR block for a subnet. Depending on the network
	// configuration, either the IPv4 or IPv6 range can be omitted. So the following
	// combinations are possible:
	//
	// * IPv4 only
	// * IPv6 only
	// * IPv4 and IPv6 (Dual Stack)
	Cidr Cidr `json:"cidr"`

	// RouteTableRef resource.Reference to the route table used by default for all Subnets.
	RouteTableRef resource.Reference `json:"routeTableRef"`

	// SkuRef resource.Reference to the SKU used by default for all NIC in this Network.
	// Can be overridden by the NIC.
	SkuRef resource.Reference `json:"skuRef"`
}

// NetworkStatus defines model for NetworkStatus.
type NetworkStatus struct {
	AdditionalCidrs *[]Cidr `json:"additionalCidrs,omitempty"`

	// Cidr Combined IPv4 and IPv6 CIDR block for a subnet. Depending on the network
	// configuration, either the IPv4 or IPv6 range can be omitted. So the following
	// combinations are possible:
	//
	// * IPv4 only
	// * IPv6 only
	// * IPv4 and IPv6 (Dual Stack)
	Cidr       Cidr                       `json:"cidr"`
	Conditions []resource.StatusCondition `json:"conditions"`

	// RouteTableRef resource.Reference to the route table used by default for all Subnets.
	RouteTableRef *resource.Reference `json:"routeTableRef,omitempty"`

	// State Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fulfill the request; would be related to provider issue or customer related input.
	State *resource.ResourceState `json:"state,omitempty"`
}

// Nic defines model for Nic.
type Nic struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	// The number of annotations is eventually limited by the CSP.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions User-defined key/value pairs that are mutable and can be used to add extensions.
	// Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	// The number of labels is eventually limited by the CSP.
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Metadata for zonal resources with name, permission, modification, type, tenant, region, and zone information.
	Metadata *resource.ZonalResourceMetadata `json:"metadata,omitempty"`

	// Spec Specification of the Network Interface Card
	//
	// The referenced SKU overwrites the default. In case of different network SKU references
	// the highest possible network SKU reference is used. The network SKU reference
	// might be restricted by the instance size.
	Spec NicSpec `json:"spec"`

	// of the NIC and the IP addresses associated with it. The status is read-only and
	// cannot be modified directly.
	Status *NicStatus `json:"status,omitempty"`
}

// NicIp IP address for the NIC. The IP is either IPv4 or IPv6. The IP
// can be `0.0.0.0` or `::` to indicate that the IP needs to be assigned
// automatically. The IP can also be a specific IP address.
// If not provided, the mutate admission controller will populate this value using the default values for ipv4 and ipv6.
type NicIp = string

// NicIterator Iterator for nics
type NicIterator struct {
	// Items List of nics
	Items []Nic `json:"items"`

	// Metadata Metadata for response objects.
	Metadata resource.ResponseMetadata `json:"metadata"`
}

// NicSpec Specification of the Network Interface Card
//
// The referenced SKU overwrites the default. In case of different network SKU references
// the highest possible network SKU reference is used. The network SKU reference
// might be restricted by the instance size.
type NicSpec struct {
	// Addresses List of IP addresses for the NIC. A specific IP address needs to be in the
	// CIDR range of the subnet and not used by any other NIC in the subnet. Multiple
	// IP addresses can be assigned to a NIC. The number of IP addresses is might be
	// limited by the CSP or the subnet size.
	Addresses []NicIp `json:"addresses"`

	// PublicIpRefs resource.References to public IP addresses associated with this NIC. The IP may be external
	// and not directly visible on the server/NIC itself.
	PublicIpRefs *[]resource.Reference `json:"publicIpRefs,omitempty"`

	// SkuRef resource.Reference to the SKU of the NIC.
	SkuRef *resource.Reference `json:"skuRef,omitempty"`

	// SubnetRef resource.Reference to the subnet used by the NIC connections.
	SubnetRef resource.Reference `json:"subnetRef"`
}

// NicStatus defines model for NicStatus.
type NicStatus struct {
	Addresses  *[]NicIp                   `json:"addresses,omitempty"`
	Conditions []resource.StatusCondition `json:"conditions"`

	// MacAddress MAC address of the NIC.
	MacAddress *string `json:"macAddress,omitempty"`

	// PublicIpRefs Array of public IP addresses associated with this NIC.
	PublicIpRefs *[]resource.Reference `json:"publicIpRefs,omitempty"`

	// State Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fulfill the request; would be related to provider issue or customer related input.
	State *resource.ResourceState `json:"state,omitempty"`
}

// Port A valid network port number.
// The port number is a 16-bit unsigned integer ranging from 1 to 65535.
type Port = int

// Ports Defines a specific port list or port range for the rule.
// The configuration allows specifying individual ports, ranges, or a combination of both.
//
// Behavior:
// - If only `from` is specified, the range is interpreted as a single port: `from` to `from`.
// - If only `to` is specified, the range is interpreted as a single port: `to` to `to`.
// - If both `from` and `to` are specified, the range spans from `from` to `to`.
// - The `list` property can be used to explicitly define additional individual ports.
//
// The final result is a comprehensive list of ports and/or port ranges.
type Ports struct {
	// From A valid network port number.
	// The port number is a 16-bit unsigned integer ranging from 1 to 65535.
	From *Port   `json:"from,omitempty"`
	List *[]Port `json:"list,omitempty"`

	// To A valid network port number.
	// The port number is a 16-bit unsigned integer ranging from 1 to 65535.
	To *Port `json:"to,omitempty"`
}

// PublicIp defines model for PublicIp.
type PublicIp struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	// The number of annotations is eventually limited by the CSP.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions User-defined key/value pairs that are mutable and can be used to add extensions.
	// Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	// The number of labels is eventually limited by the CSP.
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Metadata for regional resources with name, permission, modification, type, tenant, and region information.
	Metadata *resource.RegionalResourceMetadata `json:"metadata,omitempty"`

	// Spec Specification of the public IP.
	Spec PublicIpSpec `json:"spec"`

	Status *PublicIpStatus `json:"status,omitempty"`
}

// PublicIpIterator Iterator for public ips
type PublicIpIterator struct {
	// Items List of public ips
	Items []PublicIp `json:"items"`

	// Metadata Metadata for response objects.
	Metadata resource.ResponseMetadata `json:"metadata"`
}

// PublicIpSpec Specification of the public IP.
type PublicIpSpec struct {
	// Address The public IP address in case of BYOIP.
	Address *string `json:"address,omitempty"`

	// Version IP version of the address
	Version IPVersion `json:"version"`
}

// PublicIpStatus defines model for PublicIpStatus.
type PublicIpStatus struct {
	// AttachedTo resource.Reference to the instance the public IP is attached to.
	AttachedTo *resource.Reference        `json:"attachedTo,omitempty"`
	Conditions []resource.StatusCondition `json:"conditions"`

	// IpAddress The public IP address in case.
	IpAddress *string `json:"ipAddress,omitempty"`

	// State Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fulfill the request; would be related to provider issue or customer related input.
	State *resource.ResourceState `json:"state,omitempty"`
}

// RouteTableIterator Iterator for route-tables
type RouteTableIterator struct {
	// Items List of route-tables
	Items []RouteTable `json:"items"`

	// Metadata Metadata for response objects.
	Metadata resource.ResponseMetadata `json:"metadata"`
}

// RouteSpec The target reference can be an instance,
// a gateway or an IP address (v4 or v6) that is part of the
// network the route table is attached to.
type RouteSpec struct {
	// DestinationCidrBlock The CIDR block for the destination. The block can be
	// a specific IP address or a range of addresses. It can be
	// IPv6 or IPv4.
	DestinationCidrBlock string `json:"destinationCidrBlock"`

	// TargetRef resource.Reference to the target of the route. The target can be an instance, an gateway or an IP address.
	TargetRef resource.Reference `json:"targetRef"`
}

// RouteStatus defines model for RouteStatus.
type RouteStatus struct {
	Conditions []resource.StatusCondition `json:"conditions"`

	// State Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fulfill the request; would be related to provider issue or customer related input.
	State *resource.ResourceState `json:"state,omitempty"`
}

// RouteTable defines model for RouteTable.
type RouteTable struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	// The number of annotations is eventually limited by the CSP.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions User-defined key/value pairs that are mutable and can be used to add extensions.
	// Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	// The number of labels is eventually limited by the CSP.
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Metadata for regional resources with name, permission, modification, type, tenant, and region information.
	Metadata *resource.RegionalResourceMetadata `json:"metadata,omitempty"`

	// Spec The RouteTableSpec defines the routes that are associated with the route table.
	Spec RouteTableSpec `json:"spec"`

	// system. The status contains information about the current state of the route table
	// and its routes. It will report the status of the routes and the route table as a whole.
	Status *RouteTableStatus `json:"status,omitempty"`
}

// RouteTableSpec The RouteTableSpec defines the routes that are associated with the route table.
type RouteTableSpec struct {
	Routes []RouteSpec `json:"routes"`
}

// RouteTableStatus defines model for RouteTableStatus.
type RouteTableStatus struct {
	Conditions []resource.StatusCondition `json:"conditions"`
	Routes     *[]RouteStatus             `json:"routes,omitempty"`

	// State Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fulfill the request; would be related to provider issue or customer related input.
	State *resource.ResourceState `json:"state,omitempty"`
}

// SecurityGroup defines model for SecurityGroup.
type SecurityGroup struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	// The number of annotations is eventually limited by the CSP.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions User-defined key/value pairs that are mutable and can be used to add extensions.
	// Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	// The number of labels is eventually limited by the CSP.
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Metadata for regional resources with name, permission, modification, type, tenant, and region information.
	Metadata *resource.RegionalResourceMetadata `json:"metadata,omitempty"`

	// Spec Specification of the security group
	Spec SecurityGroupSpec `json:"spec"`

	// The status is read-only and reflects the current state of the security group.
	Status *SecurityGroupStatus `json:"status,omitempty"`
}

// SecurityGroupIterator Iterator for security-groups
type SecurityGroupIterator struct {
	// Items List of security-groups
	Items []SecurityGroup `json:"items"`

	// Metadata Metadata for response objects.
	Metadata resource.ResponseMetadata `json:"metadata"`
}

// SecurityGroupRuleSpec Specification of a security group rule defining network access permissions.
// If no version is specified, any IP version will be allowed.
// If no protocol is specified, any network protocol will be allowed.
type SecurityGroupRuleSpec struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	// The number of annotations is eventually limited by the CSP.
	Annotations *Annotations `json:"annotations,omitempty"`

	// Direction Direction of the traffic flow:
	// * ingress: Only incoming traffic is allowed
	// * egress: Only outgoing traffic is allowed
	Direction SecurityGroupRuleSpecDirection `json:"direction"`

	// Icmp ICMP specific rule configuration
	Icmp *IcmpConfig `json:"icmp,omitempty"`

	// Ports Defines a specific port list or port range for the rule.
	// The configuration allows specifying individual ports, ranges, or a combination of both.
	//
	// Behavior:
	// - If only `from` is specified, the range is interpreted as a single port: `from` to `from`.
	// - If only `to` is specified, the range is interpreted as a single port: `to` to `to`.
	// - If both `from` and `to` are specified, the range spans from `from` to `to`.
	// - The `list` property can be used to explicitly define additional individual ports.
	//
	// The final result is a comprehensive list of ports and/or port ranges.
	Ports *Ports `json:"ports,omitempty"`

	// Protocol Network protocol for the rule
	Protocol *SecurityGroupRuleSpecProtocol `json:"protocol,omitempty"`

	// SourceRefs List of CIDR blocks, IP addresses, gateways, instances or security group references that are allowed to communicate
	// with the security group. If a security group is specified, all instances in that group are allowed.
	// If no sourceRefs are specified, all traffic is allowed.
	SourceRefs *[]resource.Reference `json:"sourceRefs,omitempty"`

	// Version IP version of the address
	Version *IPVersion `json:"version,omitempty"`
}

// SecurityGroupRuleSpecDirection Direction of the traffic flow:
// * ingress: Only incoming traffic is allowed
// * egress: Only outgoing traffic is allowed
type SecurityGroupRuleSpecDirection string

// SecurityGroupRuleSpecProtocol Network protocol for the rule
type SecurityGroupRuleSpecProtocol string

// SecurityGroupSpec Specification of the security group
type SecurityGroupSpec struct {
	// Rules Network access rules defining communication between security groups and external networks.
	//
	// Rule Evaluation:
	// - Default behavior is to deny all traffic not explicitly allowed
	// - Rules provide granular control over allowed traffic types, sources, and destinations
	Rules []SecurityGroupRuleSpec `json:"rules"`
}

// SecurityGroupStatus defines model for SecurityGroupStatus.
type SecurityGroupStatus struct {
	Conditions []resource.StatusCondition `json:"conditions"`
	Rules      *[]resource.Status         `json:"rules,omitempty"`

	// State Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fulfill the request; would be related to provider issue or customer related input.
	State *resource.ResourceState `json:"state,omitempty"`
}

// SkuIterator Iterator for skus
type SkuIterator struct {
	// Items List of skus
	Items []NetworkSku `json:"items"`

	// Metadata Metadata for response objects.
	Metadata resource.ResponseMetadata `json:"metadata"`
}

// Subnet defines model for Subnet.
type Subnet struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	// The number of annotations is eventually limited by the CSP.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions User-defined key/value pairs that are mutable and can be used to add extensions.
	// Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	// The number of labels is eventually limited by the CSP.
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Metadata for zonal resources with name, permission, modification, type, tenant, region, and zone information.
	Metadata *resource.ZonalResourceMetadata `json:"metadata,omitempty"`

	// Spec Detailed specification of the subnet. Automatic address
	// assignment is supported, similar to the network configuration. The
	// subnet's prefix length must be smaller than the network's prefix
	// length, ensuring proper subdivision of the address space.
	// The first and last IP addresses in the subnet are reserved
	// the network address and broadcast address, respectively.
	//
	// Most CSP will not allow to use a different IPv6 prefix length than /64.
	Spec SubnetSpec `json:"spec"`

	// associated IP addresses. The status is read-only and provides
	// information about the subnet's configuration and health.
	Status *SubnetStatus `json:"status,omitempty"`
}

// SubnetIterator Iterator for subnets
type SubnetIterator struct {
	// Items List of subnets
	Items []Subnet `json:"items"`

	// Metadata Metadata for response objects.
	Metadata resource.ResponseMetadata `json:"metadata"`
}

// SubnetSpec Detailed specification of the subnet. Automatic address
// assignment is supported, similar to the network configuration. The
// subnet's prefix length must be smaller than the network's prefix
// length, ensuring proper subdivision of the address space.
// The first and last IP addresses in the subnet are reserved
// the network address and broadcast address, respectively.
//
// Most CSP will not allow to use a different IPv6 prefix length than /64.
type SubnetSpec struct {
	// Cidr Combined IPv4 and IPv6 CIDR block for a subnet. Depending on the network
	// configuration, either the IPv4 or IPv6 range can be omitted. So the following
	// combinations are possible:
	//
	// * IPv4 only
	// * IPv6 only
	// * IPv4 and IPv6 (Dual Stack)
	Cidr Cidr `json:"cidr"`

	// RouteTableRef resource.Reference to the route table used by default for all NICs in this Subnet.
	// If not provided, the routeTableRef associated with the network of the subnet will be used.
	RouteTableRef *resource.Reference `json:"routeTableRef,omitempty"`

	// SkuRef resource.Reference to the SKU used by default for all NICs in this Network.
	// Can be overridden by the NIC
	SkuRef *resource.Reference `json:"skuRef,omitempty"`

	Zone resource.Zone `json:"zone"`
}

// SubnetStatus defines model for SubnetStatus.
type SubnetStatus struct {
	// Cidr Combined IPv4 and IPv6 CIDR block for a subnet. Depending on the network
	// configuration, either the IPv4 or IPv6 range can be omitted. So the following
	// combinations are possible:
	//
	// * IPv4 only
	// * IPv6 only
	// * IPv4 and IPv6 (Dual Stack)
	Cidr       *Cidr                      `json:"cidr,omitempty"`
	Conditions []resource.StatusCondition `json:"conditions"`

	// RouteTableRef The route table used by this subnet.
	RouteTableRef *resource.Reference `json:"routeTableRef,omitempty"`

	// State Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fulfill the request; would be related to provider issue or customer related input.
	State *resource.ResourceState `json:"state,omitempty"`
}

// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
// The number of annotations is eventually limited by the CSP.
type Annotations map[string]string

// Cidr Combined IPv4 and IPv6 CIDR block for a subnet. Depending on the network
// configuration, either the IPv4 or IPv6 range can be omitted. So the following
// combinations are possible:
//
// * IPv4 only
// * IPv6 only
// * IPv4 and IPv6 (Dual Stack)
type Cidr struct {
	// Ipv4 IPv4 CIDR block for the subnet.
	Ipv4 *string `json:"ipv4,omitempty"`

	// Ipv6 IPv6 CIDR block for the subnet.
	Ipv6 *string `json:"ipv6,omitempty"`
}

// AcceptHeader defines model for acceptHeader.
type AcceptHeader string

// IfUnmodifiedSince defines model for ifUnmodifiedSince.
type IfUnmodifiedSince = int

// LabelSelector defines model for labelSelector.
type LabelSelector = string

// LimitParam defines model for limitParam.
type LimitParam = int

// NetworkRef defines model for networkRef.
type NetworkRef = string

// ResourceName defines model for resourceName.
type ResourceName = string

// SkipTokenParam defines model for skipTokenParam.
type SkipTokenParam = string

// Tenant defines model for tenant.
type Tenant = string

// Workspace defines model for workspace.
type Workspace = string

// ListSkusParams defines parameters for ListSkus.
type ListSkusParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListSkusParamsAccept `json:"Accept,omitempty"`
}

// ListSkusParamsAccept defines parameters for ListSkus.
type ListSkusParamsAccept string

// ListInternetGatewaysParams defines parameters for ListInternetGateways.
type ListInternetGatewaysParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListInternetGatewaysParamsAccept `json:"Accept,omitempty"`
}

// ListInternetGatewaysParamsAccept defines parameters for ListInternetGateways.
type ListInternetGatewaysParamsAccept string

// DeleteInternetGatewayParams defines parameters for DeleteInternetGateway.
type DeleteInternetGatewayParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateInternetGatewayParams defines parameters for CreateOrUpdateInternetGateway.
type CreateOrUpdateInternetGatewayParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// ListNetworksParams defines parameters for ListNetworks.
type ListNetworksParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListNetworksParamsAccept `json:"Accept,omitempty"`
}

// ListNetworksParamsAccept defines parameters for ListNetworks.
type ListNetworksParamsAccept string

// DeleteNetworkParams defines parameters for DeleteNetwork.
type DeleteNetworkParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateNetworkParams defines parameters for CreateOrUpdateNetwork.
type CreateOrUpdateNetworkParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// ListRouteTablesParams defines parameters for ListRouteTables.
type ListRouteTablesParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListRouteTablesParamsAccept `json:"Accept,omitempty"`
}

// ListRouteTablesParamsAccept defines parameters for ListRouteTables.
type ListRouteTablesParamsAccept string

// DeleteRouteTableParams defines parameters for DeleteRouteTable.
type DeleteRouteTableParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateRouteTableParams defines parameters for CreateOrUpdateRouteTable.
type CreateOrUpdateRouteTableParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// ListSubnetsParams defines parameters for ListSubnets.
type ListSubnetsParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListSubnetsParamsAccept `json:"Accept,omitempty"`
}

// ListSubnetsParamsAccept defines parameters for ListSubnets.
type ListSubnetsParamsAccept string

// DeleteSubnetParams defines parameters for DeleteSubnet.
type DeleteSubnetParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateSubnetParams defines parameters for CreateOrUpdateSubnet.
type CreateOrUpdateSubnetParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// ListNicsParams defines parameters for ListNics.
type ListNicsParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListNicsParamsAccept `json:"Accept,omitempty"`
}

// ListNicsParamsAccept defines parameters for ListNics.
type ListNicsParamsAccept string

// DeleteNicParams defines parameters for DeleteNic.
type DeleteNicParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateNicParams defines parameters for CreateOrUpdateNic.
type CreateOrUpdateNicParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// ListPublicIpsParams defines parameters for ListPublicIps.
type ListPublicIpsParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListPublicIpsParamsAccept `json:"Accept,omitempty"`
}

// ListPublicIpsParamsAccept defines parameters for ListPublicIps.
type ListPublicIpsParamsAccept string

// DeletePublicIpParams defines parameters for DeletePublicIp.
type DeletePublicIpParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdatePublicIpParams defines parameters for CreateOrUpdatePublicIp.
type CreateOrUpdatePublicIpParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// ListSecurityGroupsParams defines parameters for ListSecurityGroups.
type ListSecurityGroupsParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListSecurityGroupsParamsAccept `json:"Accept,omitempty"`
}

// ListSecurityGroupsParamsAccept defines parameters for ListSecurityGroups.
type ListSecurityGroupsParamsAccept string

// DeleteSecurityGroupParams defines parameters for DeleteSecurityGroup.
type DeleteSecurityGroupParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateSecurityGroupParams defines parameters for CreateOrUpdateSecurityGroup.
type CreateOrUpdateSecurityGroupParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateInternetGatewayJSONRequestBody defines body for CreateOrUpdateInternetGateway for application/json ContentType.
type CreateOrUpdateInternetGatewayJSONRequestBody = InternetGateway

// CreateOrUpdateNetworkJSONRequestBody defines body for CreateOrUpdateNetwork for application/json ContentType.
type CreateOrUpdateNetworkJSONRequestBody = Network

// CreateOrUpdateRouteTableJSONRequestBody defines body for CreateOrUpdateRouteTable for application/json ContentType.
type CreateOrUpdateRouteTableJSONRequestBody = RouteTable

// CreateOrUpdateSubnetJSONRequestBody defines body for CreateOrUpdateSubnet for application/json ContentType.
type CreateOrUpdateSubnetJSONRequestBody = Subnet

// CreateOrUpdateNicJSONRequestBody defines body for CreateOrUpdateNic for application/json ContentType.
type CreateOrUpdateNicJSONRequestBody = Nic

// CreateOrUpdatePublicIpJSONRequestBody defines body for CreateOrUpdatePublicIp for application/json ContentType.
type CreateOrUpdatePublicIpJSONRequestBody = PublicIp

// CreateOrUpdateSecurityGroupJSONRequestBody defines body for CreateOrUpdateSecurityGroup for application/json ContentType.
type CreateOrUpdateSecurityGroupJSONRequestBody = SecurityGroup
