package errors

import (
	"encoding/json"
	stderrors "errors"
	"log/slog"
	"net/http"

	"github.com/eu-sovereign-cloud/ecp/foundation/gateway/pkg/model"
	"github.com/eu-sovereign-cloud/go-sdk/pkg/spec/schema"
)

// RFC 7807 error type URIs
const (
	TypeInvalidRequest      = "http://secapi.eu/errors/invalid-request"
	TypeUnauthorized        = "http://secapi.eu/errors/unauthorized"
	TypeForbidden           = "http://secapi.eu/errors/forbidden"
	TypeResourceNotFound    = "http://secapi.eu/errors/resource-not-found"
	TypeResourceConflict    = "http://secapi.eu/errors/resource-conflict"
	TypePreconditionFailed  = "http://secapi.eu/errors/precondition-failed"
	TypeValidationError     = "http://secapi.eu/errors/validation-error"
	TypeInternalServerError = "http://secapi.eu/errors/internal-server-error"
)
// Sentinel errors for http handlers
var (
	ErrBadRequest         = stderrors.New("bad request")
	ErrPreconditionFailed = stderrors.New("precondition failed")
)

// DomainToSDKError converts a pure domain error to an RFC 7807 SDK error
// This is the adapter's responsibility - mapping domain to protocol
func DomainToSDKError(err error, requestPath string) schema.Error {
	// Check for domain ValidationError with field information
	var validationErr *model.ValidationError
	if stderrors.As(err, &validationErr) {
		return convertValidationError(validationErr, requestPath)
	}

	// Map domain errors to HTTP responses
	status, title, errorType := mapDomainErrorToHTTP(err)

	sdkErr := schema.Error{
		Type:     errorType,
		Title:    title,
		Status:   float32(status),
		Instance: requestPath,
	}

	detail := err.Error()
	if detail != "" {
		sdkErr.Detail = &detail
	}

	return sdkErr
}

// convertValidationError converts domain ValidationError to SDK error with sources
func convertValidationError(domainErr *model.ValidationError, requestPath string) schema.Error {
	sdkErr := schema.Error{
		Type:     TypeValidationError,
		Title:    "Unprocessable Entity",
		Status:   float32(http.StatusUnprocessableEntity),
		Instance: requestPath,
	}

	detail := domainErr.Error()
	sdkErr.Detail = &detail

	// Convert domain field name to JSON pointer
	if domainErr.Field != "" {
		sources := []schema.ErrorSource{
			{
				Pointer:   toJSONPointer(domainErr.Field),
				Parameter: domainErr.Field,
			},
		}
		sdkErr.Sources = &sources
	}

	return sdkErr
}

// toJSONPointer converts a domain field name to a JSON Pointer
// This is an adapter concern - mapping domain concepts to SDK format
func toJSONPointer(fieldName string) string {
	// Simple conversion: "Size" -> "/spec/size"
	// In real implementation, this would use proper field mapping
	return "/spec/" + fieldName
}

// mapDomainErrorToHTTP maps domain errors to HTTP status, title, and type
func mapDomainErrorToHTTP(err error) (int, string, string) {
	switch {
	case stderrors.Is(err, model.ErrForbidden):
		return http.StatusForbidden, "Forbidden", TypeForbidden
	case stderrors.Is(err, model.ErrNotFound):
		return http.StatusNotFound, "Not Found", TypeResourceNotFound
	case stderrors.Is(err, model.ErrAlreadyExists), stderrors.Is(err, model.ErrConflict):
		return http.StatusConflict, "Conflict", TypeResourceConflict
	case stderrors.Is(err, model.ErrValidation):
		return http.StatusUnprocessableEntity, "Unprocessable Entity", TypeValidationError
	case stderrors.Is(err, model.ErrUnavailable):
		return http.StatusInternalServerError, "Service Unavailable", TypeInternalServerError
	// errors generated by the http handlers
	case stderrors.Is(err, ErrBadRequest):
		return http.StatusBadRequest, "Bad Request", TypeInvalidRequest
	case stderrors.Is(err, ErrPreconditionFailed):
		return http.StatusBadRequest, "PreconditionFailed", TypePreconditionFailed
	default:
		return http.StatusInternalServerError, "Service Unavailable", TypeInternalServerError
	}
}

// WriteErrorResponse writes a structured error response according to RFC 7807.
func WriteErrorResponse(w http.ResponseWriter, r *http.Request, logger *slog.Logger, err error) {
	sdkError := DomainToSDKError(err, r.URL.Path)

	logger.ErrorContext(r.Context(), "request error",
		slog.Int("status", int(sdkError.Status)),
		slog.String("type", sdkError.Type),
		slog.String("title", sdkError.Title),
		slog.Any("detail", sdkError.Detail),
		slog.Any("error", err),
	)

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(int(sdkError.Status))

	if encodeErr := json.NewEncoder(w).Encode(sdkError); encodeErr != nil {
		logger.ErrorContext(r.Context(), "failed to encode error response", slog.Any("error", encodeErr))
		// Fallback to plain text error
		http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
	}
}
