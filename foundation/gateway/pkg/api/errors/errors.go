package errors

import (
	"encoding/json"
	stderrors "errors"
	"log/slog"
	"net/http"

	"github.com/eu-sovereign-cloud/ecp/foundation/gateway/pkg/model"
	"github.com/eu-sovereign-cloud/go-sdk/pkg/spec/schema"
)

// Sentinel errors for http handlers
var (
	ErrBadRequest         = stderrors.New("bad request")
	ErrPreconditionFailed = stderrors.New("precondition failed")
)

// DomainToSDKError converts a pure domain error to an RFC 7807 SDK error
// This is the adapter's responsibility - mapping domain to protocol
func DomainToSDKError(err error, requestPath string) schema.Error {
	// Check for domain ValidationError with field information
	var validationErr *model.ValidationError
	if stderrors.As(err, &validationErr) {
		return convertValidationError(validationErr, requestPath)
	}

	// Map domain errors to HTTP responses
	status, title, errorType := mapDomainErrorToHTTP(err)

	sdkErr := schema.Error{
		Type:     string(errorType),
		Title:    title,
		Status:   float32(status),
		Instance: requestPath,
	}

	detail := err.Error()
	if detail != "" {
		sdkErr.Detail = detail
	}

	return sdkErr
}

// convertValidationError converts domain ValidationError to SDK error with sources
func convertValidationError(domainErr *model.ValidationError, requestPath string) schema.Error {
	sdkErr := schema.Error{
		Type:     string(schema.ErrorTypeValidationError),
		Title:    "Unprocessable Entity",
		Status:   float32(http.StatusUnprocessableEntity),
		Instance: requestPath,
	}

	sdkErr.Detail = domainErr.Error()

	// Convert domain field name to JSON pointer
	if domainErr.Field != "" {
		sdkErr.Sources = []schema.ErrorSource{
			{
				Pointer:   toJSONPointer(domainErr.Field),
				Parameter: domainErr.Field,
			},
		}
	}

	return sdkErr
}

// toJSONPointer converts a domain field name to a JSON Pointer
// This is an adapter concern - mapping domain concepts to SDK format
func toJSONPointer(fieldName string) string {
	// Simple conversion: "Size" -> "/spec/size"
	// In real implementation, this would use proper field mapping
	return "/spec/" + fieldName
}

// mapDomainErrorToHTTP maps domain errors to HTTP status, title, and type
func mapDomainErrorToHTTP(err error) (int, string, schema.ErrorType) {
	switch {
	case stderrors.Is(err, model.ErrForbidden):
		return http.StatusForbidden, "Forbidden", schema.ErrorTypeForbidden
	case stderrors.Is(err, model.ErrNotFound):
		return http.StatusNotFound, "Not Found", schema.ErrorTypeResourceNotFound
	case stderrors.Is(err, model.ErrAlreadyExists), stderrors.Is(err, model.ErrConflict):
		return http.StatusConflict, "Conflict", schema.ErrorTypeResourceConflict
	case stderrors.Is(err, model.ErrValidation):
		return http.StatusUnprocessableEntity, "Unprocessable Entity", schema.ErrorTypeValidationError
	case stderrors.Is(err, model.ErrUnavailable):
		return http.StatusInternalServerError, "Service Unavailable", schema.ErrorTypeInternalServerError
	// errors generated by the http handlers
	case stderrors.Is(err, ErrBadRequest):
		return http.StatusBadRequest, "Bad Request", schema.ErrorTypeInvalidRequest
	case stderrors.Is(err, ErrPreconditionFailed):
		return http.StatusBadRequest, "PreconditionFailed", schema.ErrorTypePreconditionFailed
	default:
		return http.StatusInternalServerError, "Service Unavailable", schema.ErrorTypeInternalServerError
	}
}

// WriteErrorResponse writes a structured error response according to RFC 7807.
func WriteErrorResponse(w http.ResponseWriter, r *http.Request, logger *slog.Logger, err error) {
	sdkError := DomainToSDKError(err, r.URL.Path)

	logger.ErrorContext(r.Context(), "request error",
		slog.Int("status", int(sdkError.Status)),
		slog.String("type", sdkError.Type),
		slog.String("title", sdkError.Title),
		slog.Any("detail", sdkError.Detail),
		slog.Any("error", err),
	)

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(int(sdkError.Status))

	if encodeErr := json.NewEncoder(w).Encode(sdkError); encodeErr != nil {
		logger.ErrorContext(r.Context(), "failed to encode error response", slog.Any("error", encodeErr))
		// Fallback to plain text error
		http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
	}
}
